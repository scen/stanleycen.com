<!doctype html> <html> <head> <title> Maximum Bipartite Matching &mdash; Stanley Cen </title> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"> <link rel="author" href="/humans.txt"/> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700,300' rel='stylesheet' type='text/css'/> <link href="//cdnjs.cloudflare.com/ajax/libs/normalize/2.1.3/normalize.min.css" rel="stylesheet" type="text/css"/> <link href="/main.css" rel="stylesheet" type="text/css"/> <link href="/fontello.css" rel="stylesheet" type="text/css"/> <link type="text/css" rel="stylesheet" href="/fancybox/jquery.fancybox.css"/> <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> <script src="/jquery.mobiledetect.js"></script> <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script> <script src="//cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script> <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.form/3.45/jquery.form.min.js"></script> <script type="text/javascript" src="/fancybox/jquery.fancybox.pack.js"></script> <script src="/main.js"></script> <script type="text/javascript">
var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-4253037-6"]),_gaq.push(["_setDomainName","stanleycen.com"]),_gaq.push(["_trackPageview"]),function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https://ssl":"http://www")+".google-analytics.com/ga.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}();var _paq=_paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){var e="http://lake.stanleycen.com:8080/";_paq.push(["setTrackerUrl",e+"piwik.php"]),_paq.push(["setSiteId",1]);var a=document,p=a.createElement("script"),t=a.getElementsByTagName("script")[0];p.type="text/javascript",p.async=!0,p.defer=!0,p.src=e+"piwik.js",t.parentNode.insertBefore(p,t)}();window.heap=window.heap||[],heap.load=function(t,e){window.heap.appid=t,window.heap.config=e;var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=("https:"===document.location.protocol?"https:":"http:")+"//cdn.heapanalytics.com/js/heap.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(t){return function(){heap.push([t].concat(Array.prototype.slice.call(arguments,0)))}},p=["identify","track"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])}; heap.load("3908329247");
		</script> <noscript><p><img src="http://lake.stanleycen.com:8080/piwik.php?idsite=1" style="border:0;" alt=""/></p></noscript> </head> <body> <div id="wrapall"> <header id="header" class="hide-nav"> <a class="navicon-button"> <div class="navicon"></div> </a> <h1><a href="/">stanley cen</a></h1> <nav> <ul> <li><a href="/#projects" class="projects">projects</a></li> <li><a href="/blog" class="blog selected">blog</a></li> <li><a href="/#about" class="about">about</a></li> <li><a href="/#contact" class="contact">contact</a></li> <li><a href="http://github.com/scen/" class="github">github</a></li> </ul> </nav> </header> <div id="contentall"> <div style='height:52px'></div> <div id="blog_internal"> <div class="header parallax"> <h1 class="header">Blog</h1> </div> <div class="content"> <div class="blog-post "> <div class="masthead"> <div class="title"> <h1><a href="/blog/maximum-bipartite-matching">Maximum Bipartite Matching</a></h1> </div> <div class="date"> <time>March 18, 2012</time> </div> </div> <div class="body"> <p>In USACO, many problems can be reduced to a bipartite graph. Although finding a maximum matching in any graph is an NP-hard problem, finding a maximum matching in a bipartite graph requires an application of the max-flow algorithm.</p> <p>We'll be taking a look at <a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=93">USACO November 2011 Gold Problem #3</a> as a case study.</p> <p>This problem can be reduced to a maximum matching problem. WLOG, we'll place the horizontal lines in the left set, and the vertical lines into the right set. We will then draw an edge between a horizontal and vertical line iff they intersect. Since a maximum flow algorithm takes time to implement, taking into consideration the shape of the graph, we can reduce the complexity of the implementation. These following variables are declared:</p> <div class="highlight"><pre><span class="kt">int</span> <span class="n">N</span><span class="p">;</span> <span class="c1">//total # of lines</span>

<span class="k">struct</span> <span class="n">line</span><span class="p">{</span>

    <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>

<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">line</span><span class="o">&gt;</span> <span class="n">hor</span><span class="p">,</span> <span class="n">vert</span><span class="p">;</span> <span class="c1">//Horizontal and Vertical lines</span>

<span class="kt">int</span> <span class="n">vmatch</span><span class="p">[</span><span class="mi">300</span><span class="p">];</span> <span class="c1">//vmatch[i] represents a connection between vert line i and a horizontal line, -1 = SENTINEL</span>

<span class="kt">int</span> <span class="n">hmatch</span><span class="p">[</span><span class="mi">300</span><span class="p">];</span> <span class="c1">//hmatch[i] represents a connection between horiz line i and a vertical line, -1 = SENTINEL</span>

<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="mi">300</span><span class="p">];</span> <span class="c1">//vis[i] = whether we've visited horizontal line i yet</span>
</pre></div> <p>Given these values, we can find the maximum matching with a variation of Kuhn's Algorithm, which is described thoroughly on TopCoder.</p> <div class="highlight"><pre><span class="kt">bool</span> <span class="nf">find_match</span><span class="p">(</span><span class="kt">int</span> <span class="n">at</span><span class="p">)</span>

<span class="p">{</span>

    <span class="c1">//printf("FindMatch %dn", at);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">at</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">vis</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">at</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>

    <span class="p">{</span>

        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">at</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vmatch</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">find_match</span><span class="p">(</span><span class="n">vmatch</span><span class="p">[</span><span class="n">to</span><span class="p">]))</span>

        <span class="p">{</span>

            <span class="n">vmatch</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">at</span><span class="p">;</span>

            <span class="n">hmatch</span><span class="p">[</span><span class="n">at</span><span class="p">]</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>

            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="p">}</span>



<span class="n">memset</span><span class="p">(</span><span class="n">vmatch</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vmatch</span><span class="p">));</span>

<span class="n">memset</span><span class="p">(</span><span class="n">hmatch</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hmatch</span><span class="p">));</span>

<span class="kt">bool</span> <span class="n">path</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//whether we were able to augment a path</span>

<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//# edges in matching</span>

<span class="k">do</span>

<span class="p">{</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vis</span><span class="p">));</span>

    <span class="n">path</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hor</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hmatch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="p">{</span>

            <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">find_match</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

            <span class="n">ans</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

            <span class="n">path</span> <span class="o">|=</span> <span class="n">ret</span><span class="p">;</span>

        <span class="p">}</span>

<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">path</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span> <span class="s">"%dn"</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="n">ans</span><span class="p">);</span>
</pre></div> </div> </div> <style>.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */</style> </div> </div> </div> <footer> <div class="bar"> <div class="wrapper"> <span class="copyleft"> Designed with &lt;3 by Stanley Cen </span> <span class="latest-commit"> Running latest commit <a href="https://github.com/scen/stanleycen.com/commit/276d9ab27aa7aea54e0890c48979e039bcf00378"> 276d9ab</a> 2 hours ago: "Create static site builder." </span> </div> </div> </footer> </div> </body> </html>